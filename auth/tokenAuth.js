// Generated by CoffeeScript 1.11.1
var bcrypt, jwt, routes, utils;

bcrypt = require('bcrypt');

jwt = require('jsonwebtoken');

routes = function(route, model, router, cert) {
  router.get(route, function(req, res, next) {
    return res.send("this is the auth endpoint");
  });
  router.post(route, function(req, res, next) {
    var password, username;
    username = req.body['username'];
    password = req.body['password'];
    return model.findOne({
      username: username
    }, function(err, model) {
      var hash;
      if (err) {
        res.status(401).end();
      }
      hash = model.password;
      return bcrypt.compare(req.body['password'], hash, function(err, match) {
        var existingTokens, token;
        if (err) {
          return res.status(401).end();
        }
        if (match) {
          token = jwt.sign({
            userName: model.username,
            id: model._id,
            admin: model.is_superuser,
            salt: Math.random()
          }, cert, {
            algorithm: 'RS256'
          });
          existingTokens = JSON.parse(model.token);
          existingTokens.token.push(token);
          model.token = JSON.stringify(existingTokens);
          model.save();
          return res.status(200).json({
            key: token
          });
        } else {
          return res.status(401).end();
        }
      });
    });
  });
  router.post(route + "/logout", function(req, res, next) {
    var token;
    token = req.body["token"];
    return jwt.verify(token, cert, {
      algorithm: 'RS256'
    }, function(err, decoded) {
      var userId;
      if (err) {
        return res.status(401).end();
      }
      userId = decoded.id;
      return model.findOne({
        _id: userId
      }, function(err, object) {
        var existingTokens, index;
        if (err) {
          return res.status(401).end();
        }
        existingTokens = JSON.parse(object.token);
        index = existingTokens.token.indexOf(token);
        existingTokens.token.splice(index, 1);
        object.token = JSON.stringify(existingTokens);
        object.save();
        return res.status(200).end();
      });
    });
  });
  return router.post(route + "/signup", function(req, res, next) {
    req.body['is_superuser'] = false;
    req.body['token'] = '{"token":[]}';
    return bcrypt.hash(req.body['password'], 5, function(err, password) {
      if (err) {
        return res.status(401).end();
      }
      req.body.password = password;
      return new model(req.body).save(function(err) {
        if (err) {
          return res.status(401).json(err);
        }
        return res.send("route to create new user");
      });
    });
  });
};

utils = function(cert) {
  var is_authenticated, is_superuser;
  is_authenticated = function(token) {
    return jwt.verify(token, cert, {
      algorithm: 'RS256'
    }, function(err, decoded) {
      var userId;
      if (err) {
        return false;
      }
      userId = decoded.id;
      return model.findOne({
        _id: userId
      }, function(err, object) {
        var existingTokens, index;
        if (err) {
          return false;
        }
        existingTokens = JSON.parse(object.token);
        index = existingTokens.token.indexOf(token);
        if (index === -1) {
          return false;
        } else {
          return true;
        }
      });
    });
  };
  return is_superuser = function(token) {
    return jwt.verify(token, cert, {
      algorithm: 'RS256'
    }, function(err, decoded) {
      if (err) {
        return false;
      } else {
        return decoded.admin;
      }
    });
  };
};

module.exports["utils"] = utils;

module.exports["routes"] = routes;
